<!doctype html>
<html lang="en">
    <head>
    </head>
<body>
    <div style="display: flex; flex-direction: row;">
        <canvas id="patchCanvas" width="1024" height="1024"></canvas>
        <div style="display: flex; flex-direction: column; margin-left: 10px;">
            <input type="button" value="Reset World" onclick="clearWorld()" />
            <label for="inferenceSteps" id="inferenceStepsLabel">Inference Steps</label>
            <input type="range" id="inferenceSteps" min="1" max="500" value="20" />
            <p>Input Context</p>
            <canvas id="contextCanvas" width="256" height="256"></canvas>
            <p>Mask</p>
            <canvas id="maskCanvas" width="256" height="256"></canvas>
            <p>Result</p>
            <canvas id="resultCanvas" width="256" height="256"></canvas>
        </div>
    </div>
<script>
(() => {

    const canvas = document.getElementById('patchCanvas');
    const context = canvas.getContext('2d');

    let world = new Uint8Array(1024 * 1024 * 4); // RGBA

    let rawMousePosition = { x: 0, y: 0 };
    let cursorVisible = false;

    let tilesGenerated = 0;
    const waitingToGenerateTiles = [];

    let timeStartGenerating = 0;
    let historicalGenerationTimes = [];

    let inferenceSteps = 20;

    function clearWorld() {
        for (let i = 0; i < world.length; i += 4) {
            world[i + 0] = Math.floor(Math.random() * 256); // R
            world[i + 1] = Math.floor(Math.random() * 256); // G
            world[i + 2] = Math.floor(Math.random() * 256); // B
            world[i + 3] = 0; // A
        }
    }

    function drawWorldToCanvas() {
        const imgData = context.createImageData(1024, 1024);
        imgData.data.set(world);
        context.putImageData(imgData, 0, 0);
    }

    function canvasToB64Png(canvas) {
        return canvas.toDataURL('image/png').split(',')[1];
    }

    async function callApi(b64Image, b64Mask, steps) {
        const url = `http://localhost:6621/generate`;
        const body = {
            image_b64: b64Image,
            mask_b64: b64Mask,
            num_inference_steps: steps
        }
        const res = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(body)
        });
        return await parseApiResponse(res);
    }

    async function parseApiResponse(res) {
        if (!res.ok) {
        const t = await res.text().catch(() => '');
        throw new Error(`HTTP ${res.status}: ${t.slice(0, 500)}`);
        }

        const ct = (res.headers.get('content-type') || '').toLowerCase();

        // Common options:
        // 1) JSON: { image_b64: "..." } OR { b64: "..." } OR { image: "data:image/png;base64,..." }
        // 2) Plain text: base64
        // 3) Binary image (png/jpeg)
        if (ct.includes('application/json')) {
        const j = await res.json();
        let b64 = j.image_b64 ?? j.b64 ?? j.image ?? j.data ?? null;
        if (!b64) throw new Error('JSON response missing image base64 field (expected image_b64/b64/image/data).');
        if (b64.startsWith('data:')) b64 = b64.split(',')[1];
        return b64;
        }

        if (ct.includes('image/')) {
        const blob = await res.blob();
        const b64 = await blobToB64(blob);
        return b64;
        }

        const text = await res.text();
        const trimmed = text.trim();
        if (trimmed.startsWith('data:')) return trimmed.split(',')[1];
        return trimmed; // assume raw base64
    }

    function blobToB64(blob) {
        return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => {
            const dataUrl = r.result;
            resolve(String(dataUrl).split(',')[1]);
        };
        r.onerror = reject;
        r.readAsDataURL(blob);
        });
    }

    async function b64ToImage(b64) {
        return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = 'data:image/png;base64,' + b64;
        });
    }

    canvas.onmousemove = (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        rawMousePosition.x = x;
        rawMousePosition.y = y;
    };

    canvas.onmouseenter = (e) => {
        cursorVisible = true;
    };
    canvas.onmouseleave = (e) => {
        cursorVisible = false;
    };

    canvas.onclick = async (e) => {
        if (!rawMousePosition) return;
        
        // Get context area
        const SNAP = 64;
        const GENERATION_SIZE = 128;
        const CONTEXT_SIZE = 256;
        const snappedX = Math.floor((rawMousePosition.x - (SNAP / 2)) / SNAP) * SNAP + SNAP;
        const snappedY = Math.floor((rawMousePosition.y - (SNAP / 2)) / SNAP) * SNAP + SNAP;

        const corner = {
            x: snappedX - CONTEXT_SIZE / 2, 
            y: snappedY - CONTEXT_SIZE / 2
        };

        let tileID = tilesGenerated++;
        waitingToGenerateTiles.push({
            "x": corner.x,
            "y": corner.y,
            "generationId": tileID
        })

        // Only process 
        while (waitingToGenerateTiles[0].generationId !== tileID) {
            await new Promise((resolve) => setTimeout(resolve, 100));
        }

        // Kind of hacky but ensure canvas is up to date and there is no cursor
        drawWorldToCanvas();
        timeStartGenerating = performance.now();

        // Get pixels and convert them to a b64 image
        const contextCanvas = document.getElementById('contextCanvas');
        contextCanvas.width = CONTEXT_SIZE;
        contextCanvas.height = CONTEXT_SIZE;
        const contextCtx = contextCanvas.getContext('2d');
        const imgData = context.getImageData(corner.x, corner.y, CONTEXT_SIZE, CONTEXT_SIZE);
        contextCtx.putImageData(imgData, 0, 0);
        const b64Image = canvasToB64Png(contextCanvas);

        // Create mask (All black for now)
        const maskCanvas = document.getElementById('maskCanvas');
        maskCanvas.width = CONTEXT_SIZE;
        maskCanvas.height = CONTEXT_SIZE;
        const maskCtx = maskCanvas.getContext('2d');
        maskCtx.fillStyle = 'white';
        maskCtx.fillRect(0, 0, CONTEXT_SIZE, CONTEXT_SIZE);

        // If it hasn't been generated, make the mask white where alpha is 0
        const maskImgData = maskCtx.getImageData(0, 0, CONTEXT_SIZE, CONTEXT_SIZE);
        for (let i = 0; i < maskImgData.data.length; i += 4) {
            if (imgData.data[i + 3] === 0) {
                maskImgData.data[i] = 0;
                maskImgData.data[i + 1] = 0;
                maskImgData.data[i + 2] = 0;
                maskImgData.data[i + 3] = 255;
            } else {
                maskImgData.data[i] = 255;
                maskImgData.data[i + 1] = 255;
                maskImgData.data[i + 2] = 255;
                maskImgData.data[i + 3] = 255;
            }
        }
        maskCtx.putImageData(maskImgData, 0, 0);

        maskCtx.fillStyle = 'black';
        maskCtx.fillRect((CONTEXT_SIZE - GENERATION_SIZE) / 2, (CONTEXT_SIZE - GENERATION_SIZE) / 2, GENERATION_SIZE, GENERATION_SIZE);
        const b64Mask = canvasToB64Png(maskCanvas);


        callApi(b64Image, b64Mask, inferenceSteps).then(async (b64Result) => {
            historicalGenerationTimes.push(performance.now() - timeStartGenerating);
            const resultImg = await b64ToImage(b64Result);
            // Draw result back to world
            const resultCanvas = document.getElementById('resultCanvas');
            resultCanvas.width = CONTEXT_SIZE;
            resultCanvas.height = CONTEXT_SIZE;
            const resultCtx = resultCanvas.getContext('2d');
            resultCtx.clearRect(0, 0, CONTEXT_SIZE, CONTEXT_SIZE);
            resultCtx.drawImage(resultImg, 0, 0, CONTEXT_SIZE, CONTEXT_SIZE);
            const resultImgData = resultCtx.getImageData(0, 0, CONTEXT_SIZE, CONTEXT_SIZE);

            console.log('Pasting generated area back to world at', corner);

            // Copy generated area back to world
            for (let y = 0; y < GENERATION_SIZE; y++) {
                for (let x = 0; x < GENERATION_SIZE; x++) {
                    const worldX = corner.x + (CONTEXT_SIZE - GENERATION_SIZE) / 2 + x;
                    const worldY = corner.y + (CONTEXT_SIZE - GENERATION_SIZE) / 2 + y;
                    const worldIdx = (worldY * 1024 + worldX) * 4;
                    const resultIdx = ((y + (CONTEXT_SIZE - GENERATION_SIZE) / 2) * CONTEXT_SIZE + (x + (CONTEXT_SIZE - GENERATION_SIZE) / 2)) * 4;

                    world[worldIdx + 0] = resultImgData.data[resultIdx + 0];
                    world[worldIdx + 1] = resultImgData.data[resultIdx + 1];
                    world[worldIdx + 2] = resultImgData.data[resultIdx + 2];
                    world[worldIdx + 3] = 255;
                }
            }

            waitingToGenerateTiles.shift();
        }).catch((err) => {
            console.error('API call failed:', err);
        });
    }

    const draw = () => {
        context.clearRect(0, 0, canvas.width, canvas.height);
        drawWorldToCanvas();
        drawWaitingTiles();
        drawCusor();

        window.requestAnimationFrame(draw, 16);
    };

    const drawWaitingTiles = () => {
        const SNAP = 64;
        const GENERATION_SIZE = 128;
        const CONTEXT_SIZE = 256;

        let avgTime;
        if (historicalGenerationTimes.length === 0) 
            avgTime = 8000; // Default to 5s
        else 
            avgTime = historicalGenerationTimes.reduce((a, b) => a + b, 0) / historicalGenerationTimes.length;

        for (let i = 0; i < waitingToGenerateTiles.length; i++) {
            const tile = waitingToGenerateTiles[i];
            context.beginPath();
            context.rect(tile.x + (CONTEXT_SIZE - GENERATION_SIZE) / 2, tile.y + (CONTEXT_SIZE - GENERATION_SIZE) / 2, GENERATION_SIZE, GENERATION_SIZE);
            context.strokeStyle = 'cyan';
            context.stroke();

            if (i == 0) {
                context.fillStyle = 'rgba(0, 255, 255, 0.5)';
                context.strokeStyle = 'rgba(0, 180, 180, 1)';
                const timeWaiting = performance.now() - timeStartGenerating;
                const progress = Math.min(timeWaiting / avgTime, 1.0);
                context.beginPath();
                context.moveTo(tile.x + CONTEXT_SIZE / 2, tile.y + CONTEXT_SIZE / 2);
                context.arc(tile.x + CONTEXT_SIZE / 2, tile.y + CONTEXT_SIZE / 2, 20, -Math.PI / 2, -Math.PI / 2 + progress * 2 * Math.PI);
                context.fill();

                context.beginPath();
                context.arc(tile.x + CONTEXT_SIZE / 2, tile.y + CONTEXT_SIZE / 2, 20, 0, 2 * Math.PI);
                context.stroke();
            }
        }
    }

    const drawCusor = () => {
        if (!cursorVisible) return;
        const SNAP = 64;
        const GENERATION_SIZE = 128;
        const CONTEXT_SIZE = 256;
        const snappedX = Math.floor((rawMousePosition.x - (SNAP / 2)) / SNAP) * SNAP + SNAP;
        const snappedY = Math.floor((rawMousePosition.y - (SNAP / 2)) / SNAP) * SNAP + SNAP;

        context.beginPath();
        context.rect(snappedX - CONTEXT_SIZE / 2, snappedY - CONTEXT_SIZE / 2, CONTEXT_SIZE, CONTEXT_SIZE);
        context.strokeStyle = '#00FF00';
        context.fillStyle = 'rgba(0, 255, 0, 0.2)';
        context.stroke();
        context.fill();

        context.beginPath();
        context.rect(snappedX - GENERATION_SIZE / 2, snappedY - GENERATION_SIZE / 2, GENERATION_SIZE, GENERATION_SIZE);
        context.strokeStyle = 'red';
        context.fillStyle = 'rgba(255, 0, 0, 0.2)';
        context.stroke();
        context.fill();
    }

    const updateHTML = () => {
        document.getElementById('inferenceStepsLabel').textContent = `Inference Steps: ${inferenceSteps}`;
    };

    updateHTML();

    document.getElementById('inferenceSteps').oninput = (e) => {
        inferenceSteps = Number(e.target.value);
        updateHTML();
    };

    clearWorld();

    draw();

})();
</script>
</body>
</html>